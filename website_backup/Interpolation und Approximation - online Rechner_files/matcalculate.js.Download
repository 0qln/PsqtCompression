function initArray(A,B,C){var D,E;const F=new Array(A);for(D=A;--D>=0;)F[D]=new Array(B);if(C){for(D=A;--D>=0;)for(E=B;--E>=0;)F[D][E]=0.0}return F}function matPlus(A,B){const C=A.length,D=A[0].length;if(C!=B.length||D!=B[0].length)throw"Matrizen mit unterschiedlicher Ordnung (nxm) kann man nicht addieren";const E=initArray(C,D);for(var F=C;--F>=0;){const G=E[F],H=A[F],I=B[F];for(var J=D;--J>=0;)G[J]=H[J]+I[J]}return E}function matMinus(A,B){const C=A.length,D=A[0].length;if(C!=B.length||D!=B[0].length)throw"Matrizen mit unterschiedlicher Ordnung (nxm) kann man nicht subtrahieren";const E=initArray(C,D);for(var F=C;--F>=0;){const G=E[F],H=A[F],I=B[F];for(var J=D;--J>=0;)G[J]=H[J]-I[J]}return E}function matTimes(A,B){const C=A.length,D=A[0].length,E=B.length,F=B[0].length,G=((C==1&&D==1)?1:0)+((E==1&&F==1)?2:0);var H,I,J,K,L;if(G===0){if(D!=E)throw"unzulässige Zeilen-/Spaltenkombination der Matrizen bei der Multiplikation";K=initArray(C,F);for(H=C;--H>=0;){const M=K[H],N=A[H];for(J=F;--J>=0;){M[J]=0;for(I=D;--I>=0;)M[J]+=N[I]*B[I][J]}}}else if(G==1){const O=A[0][0];K=initArray(E,F);for(I=E;--I>=0;){const P=B[I];L=K[I];for(J=F;--J>=0;)L[J]=O*P[J]}}else{const Q=B[0][0];K=initArray(C,D);for(I=C;--I>=0;){const R=A[I];L=K[I];for(J=D;--J>=0;)L[J]=R[J]*Q}}return K}function matTimesVector(A,b){const B=A.length,C=A[0].length,D=b.length;if(C!=D)throw"unzulässige Zeilen-/Spaltenkombination bei der Multiplikation";const E=new Array(B);for(var F=B;--F>=0;){const G=A[F];var H=0;for(var I=C;--I>=0;)H+=G[I]*b[I];E[F]=H}return E}function matTranspose(A,B){const C=A.length,D=A[0].length,E=B==undefined?initArray(D,C):B;for(var F=C;--F>=0;){const G=A[F];var H;if(A!=E)for(H=D;--H>=0;)E[H][F]=G[H];else{for(H=F;--H>=0;){const I=A[H][F];A[H][F]=G[H];G[H]=I}}}return E}function matCopy(A,B){const C=B==undefined?new Array(A.length):B;for(var D=A.length;--D>=0;)C[D]=A[D].slice();return C}function matPower(A,n){const B=A.length,C=A[0].length;var D,E;if(B!=C)throw"Potenz nur bei quadratischen Matrizen!";if(n===0){D=initArray(B,C,!0);for(E=B;--E>=0;)D[E][E]=1;return D}if(n<0){A=matCopy(A);if(matInverse(A)===null)throw"singuläre Matrix";n=-n}const F=[];E=0;while(n>0){F[E]=n&1?1:0;++E;n>>=1}D=matCopy(A);for(E=F.length-1;--E>=0;){D=matTimes(D,D);if(F[E]==1)D=matTimes(D,A)}return D}function matScale(A,c){const B=A.length,C=A[0].length,D=initArray(B,C);for(var E=B;--E>=0;){const F=D[E],G=A[E];for(var H=C;--H>=0;)F[H]=G[H]*c}return D}function matNorm1(A){const B=A.length,C=A[0].length;var D,E=0;for(var F=C;--F>=0;){D=0;for(var G=B;--G>=0;)D+=Math.abs(A[G][F]);if(D>E)E=D}return E}function matNormI(A){const B=A.length,C=A[0].length;var D,E=0;for(var F=0;F<B;++F){const G=A[F];D=0;for(var H=C;--H>=0;)D+=Math.abs(G[H]);if(D>E)E=D}return E}function matNorm2(A){const B=A[0].length,C=matTranspose(A),D=matTimes(C,A),E=[],F=[];for(var G=B;--G>=0;)F[G]=[];jacobi(D,E);return Math.sqrt(E[B-1])}function matNormF(A){const B=A.length,C=A[0].length;var D=0;for(var E=B;--E>=0;){const F=A[E];for(var G=C;--G>=0;)D+=F[G]*F[G]}return Math.sqrt(D)}
